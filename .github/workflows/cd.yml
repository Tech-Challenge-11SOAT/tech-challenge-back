name: Deploy Back to EKS

on:
  push:
    branches: ["develop"]

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout código
        uses: actions/checkout@v4

      - name: Configurar JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: maven

      - name: Build projeto e gerar JAR
        run: mvn clean package -DskipTests=true

      - name: Login no Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build e Push da imagem
        run: |
          IMAGE=nicolasmartinss/techchallenge-api:${{ github.sha }}
          docker build -t $IMAGE -f docker/Dockerfile .
          docker push $IMAGE
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: arn:aws:iam::601920909369:role/aws-actions

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name tech-challenge-cluster --region us-east-1

      - name: Garantir namespace techchallenge
        run: |
          kubectl get namespace techchallenge || kubectl create namespace techchallenge

      - name: Obter endpoint do RDS (via state no S3)
        run: |
          RDS_ENDPOINT=$(aws s3 cp s3://tech-challenge-soat11-terraform-state/rds/terraform/state - | jq -r '.outputs.rds_endpoint.value')
          echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV

      - name: Criar/atualizar Secret do banco
        run: |
          kubectl create secret generic tech-api-secret \
            --namespace techchallenge \
            --from-literal=DB_HOST=$RDS_ENDPOINT \
            --from-literal=DB_PORT=3306 \
            --from-literal=DB_NAME=${{ secrets.TF_VAR_DB_NAME }} \
            --from-literal=DB_USER=${{ secrets.TF_VAR_DB_USERNAME }} \
            --from-literal=DB_PASSWORD=${{ secrets.TF_VAR_DB_PASSWORD }} \
            --from-literal=JWT_SECRET=${{ secrets.JWT_SECRET }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Atualizar Deployment com nova imagem
        run: |
          sed -i "s|image: nicolasmartinss/techchallenge-api:.*|image: $IMAGE|" k8s-manifests/deployment.yaml
          kubectl apply -f k8s-manifests/

      - name: Deploy to Kubernetes
        run: kubectl apply -f k8s-manifests/

      - name: Esperar LoadBalancer
        run: |
          echo "Aguardando o LoadBalancer estar pronto..."
          for i in {1..30}; do
            LB_HOST=$(kubectl get svc tech-api-service -n techchallenge -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$LB_HOST" ]; then
              echo "LOAD_BALANCER=$LB_HOST" >> $GITHUB_ENV
              break
            fi
            sleep 10
          done

      - name: Mostrar URL do serviço
        run: |
          echo "A aplicação está disponível em: http://$LOAD_BALANCER"
